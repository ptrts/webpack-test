
function bootstrapWebpack(modules) {

    // objects to store loaded and loading chunks

    // Объекы для сохранения загруженных чанков и чанков в процессе загрузки
    var installedChunks = {
        2: 0
    };

    // install a JSONP callback for chunk loading

    // Перед тем, как присваивать в window.webpackJsonp новую функцию, сохраним имеющуюся функцию
    // При наличии старой функции, новая функция будет исполнять свой собственный код, и потом вызывать старую функцию.
    var parentJsonpFunction = window["webpackJsonp"];

    // Кладем в эту переменную окна webpackJsonp определенную функцию
    window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {

        // add "moreModules" to the modules object,
        // then flag all "chunkIds" as loaded and fire callback

        // Инициализируем несколько важных переменных
        var moduleId, chunkId, i = 0, resolves = [], result;

        // Берем массив идентификаторов чанков
        // Делаем по нему цикл
        //
        // Перекачиваем данные чанков chunkIds из installedChunks в resolves.
        // То что в installedChunks - удалить.
        // resolves - это пустой массив, который мы заполняем с чистого листа.
        for(; i < chunkIds.length; i++) {

            // Берем текущий чанк
            chunkId = chunkIds[i];

            // Пытаемся взять из объекта установленных чанков данные по ключу, равному идетификатору текущего чанка
            // Объект installedChunks инициализируется только как installedChunks.2 === 0
            // Соответственно, при вызове данной функции из bar.js, когда сюда передадут chunkIds === [0],
            // в installedChunks не будет installedChunks.0
            let installedChunk = installedChunks[chunkId];

            // С чанками суть следующая. В webpackJsonp передается массив чанков, которые там нужно попытаться зарезолвить.
            //

            // Что-нибудь там было, в объекте установленных чанков?
            if (installedChunk) {

                // Да, что-то есть

                // Берем это что-то.
                // Это что-то - это массив.
                // Берем из него первый элемент.
                // Далее по коду выяснится, что первый элемент массива-чанка - это функция, которую можно вызвать без параметров.
                let chunkInstallationResolve = installedChunk[0];

                // Этот первый элемент - это какой-то там резолв.
                // Добавляем его к массиву резолвов.
                resolves.push(chunkInstallationResolve);
            }

            // Хоть нашли текущий чанк в установленных, хоть не нашли, все равно кладем на его место ноль, чтоб его там больше не было
            // Удаляем текущий чанк из объекта с установленными чанками
            installedChunks[chunkId] = 0;
        }

        // Берем аргумент moreModules
        // Перекачиваем оттуда все модули в объект modules.
        // Берем при этом только те модули, которые являются собственными пропертями объекта moreModules.
        // Возможно это оверинжиниринг появившийся из-за пропускания исходного кода WebPack через какие-то
        // оптимизаторы, транспайлеры и т.д.
        for (moduleId in moreModules) {

            // Здесь происходит что-то совсем страшное
            // Через прототип, берем функцию hasOwnProperty, которая есть у всех объектов.
            // Вызываем ее на объекте moreModules.
            // Передаем в эту функцию moduleId.
            //
            // Получается вот так:
            //      moreModules.hasOwnProperty(moduleId)
            //
            // Проверяем, является ли текущий moduleId собственным свойством объекта moreModules, из
            // которого этот moduleId собственно и вытащили.
            if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {

                // Да, moduleId это собственное свойство объекта moreModules

                // Берем данные из moreModules, и перекачиваем их в объект modules


                // modules - это параметр бутстрапа самого вебпака
                // moreModules - это параметр запуска функции webpackJsonCallback
                modules[moduleId] = moreModules[moduleId];
            }
        }

        // Вызывать старую функцию webpackJsonp, если она была такая старая
        // Вызываем с теми же параметрами.
        // Старая функция будет взаимодействовать с другими modules и другими installedChunks
        if (parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);

        // resolves - это массив функций, надерганных из чанков. Чанки - это объекты, у которых такие функции есть.
        // точнее, это даже не просто чанки, а installedChunks.
        // в массиве они лежат не по индексам, а подряд, в порядке добавления в массив.
        //
        // resolves - это массив функций, надерганных из установленных чанков.
        //
        // Выполняем все эти функции
        //
        // Всем чанкам, из переданных в webpackJsonp, находившимся в процессе загрузки, выполнить их функции resolve.
        // Эти функции resolve являются частями промисов этих самых чанков.
        while (resolves.length) {
            resolves.shift()();
        }

        // executeModules - это третий параметр нашей функции webpackJsonp
        // это массив.
        // Смотрим, задан ли данный параметр функции
        if (executeModules) {

            // Задан

            // Делаем цикл по этому массиву
            for(i = 0; i < executeModules.length; i++) {

                // Вытаскиваем текущий модуль
                let executeModuleId = executeModules[i];

                // Складываем его в переменную s
                __webpack_require__.s = executeModuleId;

                // Выполняем данный модуль
                // Экспорты получаем в виде result
                result = __webpack_require__(executeModuleId);
            }
        }

        // Возвращаем результат последнего модуля, который мы выполняли в цикле
        return result;
    };

    // Какой-то кеш установленных модулей
    // Это объект.
    // Ключи этого объекта - это целые числа.
    var installedModules = {};

    // Самая главная функция нашего вебпака
    // В нее параметром заходит идентификатор модуля, который есть какое-то целое число
    function __webpack_require__(moduleId) {

        // Check if module is in cache


        // Смотрим, есть ли переданный в функцию модуль уже в кеше
        if (installedModules[moduleId]) {

            // Да, есть

            // Возвращаем экспорты этого самого модуля, который уже в кеше
            return installedModules[moduleId].exports;
        }

        // Нет, такого модуля в кеше еще нет

        // Создаем незаполненный пока объект для нового модуля, чистенький и свеженький
        // Кладем его сразу в кеш установленных модулей
        var module = installedModules[moduleId] = {

            // Идентификатор модуля
            i: moduleId,

            // Флаг, показывающий, загружен уже модуль или нет
            l: false,

            // Экспорты данного модуля
            exports: {}
        };

        // Execute the module function

        // Как известно, модули у нас это функции.
        // Вообще, модуль это код, который выполняется, и в результате его выполнения заполняется объект экспортов данного модуля.
        // Ну так вот, этот модуль-код выполнен в виде функции.
        // То, где мы сейчас есть - это как раз то место, где эта функция модуля выполняется.

        // Берем себе модуль-функцию
        let moduleToInstall = modules[moduleId];

        // Вызываем данную функцию
        moduleToInstall.call(

            // this, с которым вызывается данная функция.
            // Почему-то вместо this мы устанавливаем экспорты нашего модуля.
            // Хотя, функции модулей не обращаются к this.
            // ну да ладно
            module.exports,

            // Параметры функции

            // Сам модуль
            module,

            // Экспорты модуля (зачем, ведь сам модуль тоже передается?)
            module.exports,

            // Функция для импорта других модулей, которые могут понадобиться данному модулю
            __webpack_require__
        );

        // Помечаем, что данный модуль уже загружен
        module.l = true;

        // Возвращаем экспорты данного модуля
        return module.exports;
    }

    // This file contains only the entry chunk.
    // The chunk loading function for additional chunks


    // Какая-то функция e (requireEnsure)
    // Принимает идентификатор чанка

    __webpack_require__.e = function requireEnsure(chunkId) {

        // Достаем данные установки данного чанка
        var installedChunkData = installedChunks[chunkId];

        // Если там 0 (а мы видели место, где так устанавливается)
        // 0 наверное ставится тогда, когда чанк уже загруженный.
        // Тогда нам возвращают промис, который резолвится прям сразу
        if(installedChunkData === 0) {

            // То возвращаем промис, который резолвит сразу, причем не предоставляя никаких значений
            return new Promise(function(resolve) {
                resolve();
            });
        }

        // Нет, данные текущего чанка не равны 0

        // a Promise means "currently loading".

        // Ладно, данные чанка не ноль, теперь проверим, может быть там лежит какой-нибудь массив, например?
        if (installedChunkData) {

            // Если данные загружаемого чанка не пустые, стало быть загрузка данного чанка все еще в процессе

            // Да, там что-то лежит.
            // Лежать там может объект с числовыми ключами или массив.
            // Вернем значение по ключу 2 этого объекта или массива
            // Там должен лежать промис, который был создан и положен туда ранее
            return installedChunkData[2];
        }

        // Данные загрузки переданного нам сюда чанка еще не определены

        // Стало быть, чанк еще не загружался. Надо бы его сейчас загрузить

        // Сооружаем промис загрузки данного чанка
        // Этот промис мы будем возвращать из функции requireEnsure(chunkId)
        // Функции resolve и reject управляют жизненным циклом этого нашего промиса.
        var promise = new Promise(function(resolve, reject) {

            // Сразу же, при инициализации данного промиса будут выполнены вот такие вещи

            // Будут сформированы данные загрузки чанка
            installedChunkData = [resolve, reject];

            // Эти данные будут положены в объект загружаемых и загруженных чанков
            installedChunks[chunkId] = installedChunkData;
        });

        // Кладем этот промис элементом 2 в данные загружаемого чанка

        installedChunkData[2] = promise;

        // Данные загружаемого чанка, это выходит вот такие:
        //      0 - resolve
        //      1 - reject
        //      2 - Promise, срабатывающий, при вызове вышеуказанных функций resolve и reject

        // Начинаем собственно загрузку чанка

        // Получаем head текущего документа
        var head = document.getElementsByTagName('head')[0];

        // Создаем тег со скриптом
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.charset = 'utf-8';
        script.async = true;
        script.timeout = 120000;

        // Если есть nc (nonce), ставим его в скрипт
        if(__webpack_require__.nc) {
            script.setAttribute("nonce", __webpack_require__.nc);
        }

        // Начинаем составлять имя файла нашего скрипта
        // префикс (p) - номер чанка - .chunk.js
        script.src = __webpack_require__.p + "" + chunkId + ".chunk.js";

        // Заряжаем функцию, которая ниже, на 120 секунд, две минуты, короче
        // Это ошибка загрузки скрипта по таймауту
        // Получаем ссылку на созданный таймаут
        var timeout = setTimeout(onScriptComplete, 120000);

        // При ошибке - тоже вызываем эту функцию
        // При успешной загрузке - тоже вызываем эту функцию
        script.onerror = script.onload = onScriptComplete;

        // Вопрос. Почему мы на onload вешаем ту же самую функцию, которая если выполняется, то про чанк записывается информация, что он загружен ошибочно?

        function onScriptComplete() {

            // Делаем некоторые вещи против утечек памяти в IE

            // Очищаем нашему скрипту свойства onerror и onload
            script.onerror = script.onload = null;

            // Закрываем таймаут
            clearTimeout(timeout);

            // Получаем данные загрузки текущего чанка, для которого мы добавляли скрипт
            var chunk = installedChunks[chunkId];

            // Данные загрузки текущего чанка, это случайно не ноль?
            // Если чанк загрузился нормально, то он вызвал функцию webpackJsonp, которая когда отрабатывает,
            // то должна пометить чанки нулями и зарезолвить эти самые чанки.
            // Если чанк этого сделать не смог, стало быть, что-то с ним не так, произошла ошибка
            if(chunk !== 0) {

                // Нет, не ноль, наш чанк еще не загрузился

                // Ладно, он не ноль. Но там что-нибудь есть вообще?
                if(chunk) {

                    // Что-нибудь есть

                    // Оформляем reject нашего чанка. Почему reject? А когда будет resolve?

                    // Берем оттуда chunk[1] == reject
                    let reject = chunk[1];

                    // Составляем объект исключения
                    let error = new Error('Loading chunk ' + chunkId + ' failed.');

                    // Вызываем наш reject с составленным объектом исключения
                    reject(error);
                }

                // Убираем из загружаемых чанков данные загрузки текущего чанка
                installedChunks[chunkId] = undefined;
            }
        }

        // Цепляем наш собранный скрипт в head нашего текущего документа
        head.appendChild(script);

        return promise;
    };

    // Это массив модулей-функций. То есть, тех модулей, которые можно запустить на инициализацию
    __webpack_require__.m = modules;

    // Это объекты вот такого типа
    // {
    //      i: <идентификатор>,
    //      l: <флаг нахождения в процессе загрузки>,
    //      exports: <объект экспортов модуля>
    // }
    __webpack_require__.c = installedModules;

    // Есть такой ES6, который также называется ES Harmony, ES6 Harmony или просто Harmony.
    // Называется он так потому, что в свое время ES разделилось на ES3.1 и ES4. Потом из ES4 вышел ES5, который
    // также называется ES2016. Разделение стало ES3.1 и ES5, или ES3.1 и ES2016.
    // Сейчас готовится к выпуску новый ES6, который объединит ES3.1 и ES5.
    // Поэтому ES6 и называется Harmony, потому что он объединяет две ранее разделившиеся ветки ES.
    //
    // У этого ES есть какой-то свой интерфейс, или какая-то своя реализация подключения модулей.
    // Под эту реализацию в вебпаке есть какие-то свои наработки и заделы.
    // Суть в том, что стороние модули бывают совместимыми с Harmony и не совместимыми.
    // С теми, которые совместимые, с ними нужно уметь работать.

    // identity function for calling harmony imports with the correct context

    // Для хармони модулей нужна функция выдающая identity
    // Эта функция будет у нас храниться вот тут
    // Вероятно, адаптер js файлов, который встроен в сборщик вебпака, он как-то пропаливает про модули, совместимы
    // они с хармони или нет, и если совместимы, то заворачивает их в модуль-функцию каким-то особым образом, что
    // там внутри функции будут использоваться свойства i, d и т.д.
    __webpack_require__.i = function(value) {
        return value;
    };

    // d (define harmony export)
    //
    // Функция, которая делает в экспортах нечто с именем name, и назначает ему функцию getter в качестве геттера
    // Ну ок. Если кто-нибудь внутри модуля захочет создать хармони экспорт с неким готовым геттером, то вот,
    // как раз будет вот эта наша функция, вызовы которой вебпаковский препроцессор навставляет в тех местах, где
    // экспорты с геттерами определяются при помощи родного синтаксиса хармони.
    __webpack_require__.d = function(exports, name, getter) {

        // Есть ли в объекте exports свойство name?
        if(!__webpack_require__.o(exports, name)) {

            // Нет. В объекте exports нет свойства name

            // Добавить в объект exports свойство name
            Object.defineProperty(

                exports,

                name,

                // Положиь туда вот такой объект
                // Как раз объекты такого вида должны лежать в экспортах, если наш модуль поддерживает хармони
                // Это называется интерфейс модулей хармони
                {

                    // Этот самый name объявляется НЕ конфигурируемым
                    configurable: false,

                    // name объявляется перечислимым (что бы это ни значило)
                    enumerable: true,

                    // Геттером этого name признается getter, который нам передали в данную функцию
                    get: getter
                }
            );
        }
    };

    // Функция для выковыривания из экспортов экспорта по-умолчанию
    // Вероятно, этот метод используется не для извлечения экспортов модулями, а для извлечения экспортов
    // самими вебпаком, чтобы их как-то предварительно обработать, и разложить их в объекте экспортов по-новому, для
    // употребления другими модулями уже без оглядки на то, что объект экспортов может иметь разный формат, хармони и
    // не хармони.
    //
    // С другой стороны, хармони модули могут всегда общаться друг с другом с рассчетом на то, что объект экспортов
    // имеет хармони интерфейс. А которые не хармони, они могут пользоваться вот этими специальными функциями
    __webpack_require__.n = function(module) {

        // Нам в эту функцию передают нечто module
        // То ли это модуль-функция, то ли экспорты, получившиеся в результате работы этой модуль-функции
        // Вроде бы свойство __esModule, оно есть именно у экспортов модуля

        // Начинаем готовить функцию геттер

        // Если в экспортах модуля есть свойство __esModule, то из экспортов нужно взять свойство default
        // Если модуль старый, то нужно просто взять весь объект экспорта, и это будет как default

        var getter = module && module.__esModule

            ?
            function getDefault() {
                return module['default'];
            }

            :
            function getModuleExports() {
                return module;
            };

        __webpack_require__.d(getter, 'a', getter);

        return getter;
    };

    // Object.prototype.hasOwnProperty.call
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };

    // __webpack_public_path__
    __webpack_require__.p = "";

    // on error function for async loading
    __webpack_require__.oe = function(err) {
        console.error(err);
        throw err;
    };
}

// Вызвать инициализацию вебпака
bootstrapWebpack(
    [
        // Массив модулей здесь передается пустой
    ]
);
